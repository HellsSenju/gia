#include <iostream>
#include <locale> // Для setlocale
using namespace std;

template<typename T>
struct HashTableNode {
    string key;
    T data;
    HashTableNode* next;

    HashTableNode(string key, T data) {
        this->key = move(key);
        this->data = data;
        next = nullptr;
    }
};

template<typename T>
struct HashTable {
    int size;                        // Размер таблицы
    int current_size;                // Текущее количество элементов
    float load_factor;              // Коэффициент загрузки
    HashTableNode<T>** arr;         // Массив указателей на цепочки

    explicit HashTable(const int size, const float load_factor = 0.75f) {
        this->size = size;
        this->load_factor = load_factor;
        this->current_size = 0;
        this->arr = new HashTableNode<T> *[size];
        for (int i = 0; i < size; i++) arr[i] = nullptr;
    }

    ~HashTable() {
        for (int i = 0; i < size; i++) {
            HashTableNode<T>* node = arr[i];
            while (node != nullptr) {
                HashTableNode<T>* temp = node;
                node = node->next;
                delete temp;
            }
        }
        delete[] arr;
    }

    int hash_function(const string& key) const {
        int value = 0;
        for (char c : key) {
            value += c;
        }
        return value % size;
    }

    void insert(const string& key, const T data) {
        insert_table(key, data, arr, size);
        current_size++;

        if (current_size >= size * load_factor) {
            rehash();
        }
    }

    void insert_table(const string& key, const T data, HashTableNode<T>** target_arr, int target_size) {
        int index = 0;
        for (char c : key) {
            index += c;
        }
        index %= target_size;

        auto* new_node = new HashTableNode<T>(key, data);
        if (target_arr[index] == nullptr) {
            target_arr[index] = new_node;
        }
        else {
            HashTableNode<T>* current = target_arr[index];
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = new_node;
        }
    }

    void rehash() {
        int new_size = size * 2;
        auto** new_arr = new HashTableNode<T> *[new_size];
        for (int i = 0; i < new_size; i++) {
            new_arr[i] = nullptr;
        }

        for (int i = 0; i < size; i++) {
            HashTableNode<T>* current = arr[i];
            while (current != nullptr) {
                insert_table(current->key, current->data, new_arr, new_size);
                HashTableNode<T>* to_delete = current;
                current = current->next;
                delete to_delete;
            }
        }

        delete[] arr;
        arr = new_arr;
        size = new_size;
    }

    void print() const {
        for (int i = 0; i < size; i++) {
            HashTableNode<T>* current = arr[i];
            if (current == nullptr) continue;

            cout << "Index " << i << ": ";
            while (current != nullptr) {
                cout << "[" << current->key << ": " << current->data << "]";
                if (current->next != nullptr) cout << " -> ";
                current = current->next;
            }
            cout << endl;
        }
    }
};

int main() {
    setlocale(LC_ALL, "Russian"); // Русская локализация
    HashTable<int> table(5, 0.75f);

    table.insert("13", 1);
    table.insert("33", 3);
    table.insert("77", 7);
    table.insert("89", 8);
    table.insert("98", 9);
    table.insert("99", 99);
    table.insert("999", 999);

    cout << "Хеш-таблица после вставок:\n";
    table.print();

    table.insert("new", 100);
    table.insert("another", 200);

    cout << "\nПосле перехеширования:\n";
    table.print();

    return 0;
}
